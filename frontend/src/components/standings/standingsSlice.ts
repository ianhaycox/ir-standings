// This file demonstrates typical usage of Redux Toolkit's createSlice function
// for defining reducer logic and actions, as well as related thunks and selectors.

import { createAsyncThunk, createSlice } from "@reduxjs/toolkit"
import type { RootState } from "../../app/store"
import { fetchStandings } from "./standingsAPI"


export interface SerializablePredictedStanding {
  cust_id: number;
  driver_name: string;
  car_number?: string;
  current_position?: number;
  predicted_position: number;
  current_points: number;
  predicted_points: number;
  change: number;
  car_names: string[];
}

export interface SerializableStanding {
  sof_by_car_class: number;
  car_class_id: number;
  class_leader_laps_complete: number;
  items: SerializablePredictedStanding[];
}

export interface SerializablePredictedStandings {
  track_name: string;
  count_best_of: number;
  standings: {[key: number]: SerializableStanding}; // By Car Class ID
}

export interface PS {
  cust_id: number;
  driver_name: string;
  car_number?: string;
  current_position?: number;
  predicted_position: number;
  current_points: number;
  predicted_points: number;
  change: number;
}

// Define the TS type for the standings slice's state
export interface StandingsState {
  standings: SerializablePredictedStandings
  status: "idle" | "loading" | "failed"
}

// Define the initial value for the slice state
const initialState: StandingsState = {
  standings: <SerializablePredictedStandings>{},
  status: "idle",
}

// Slices contain Redux reducer logic for updating state, and
// generate actions that can be dispatched to trigger those updates.
export const standingsSlice = createSlice({
  name: "standings",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(fetchAsync.pending, state => {
        state.status = "loading"
      })
      .addCase(fetchAsync.fulfilled, (state, action) => {
        state.status = "idle"
        state.standings = action.payload //  serialize(action.payload)
      })
      .addCase(fetchAsync.rejected, state => {
        state.status = "failed"
      })
  },
})

// Export the slice reducer for use in the store configuration
export default standingsSlice.reducer

// Selector functions allows us to select a value from the Redux root state.
// Selectors can also be defined inline in the `useSelector` call
// in a component, or inside the `createSlice.selectors` field.
export const selectStandings = (state: RootState) => state.standings.standings
export const selectStatus = (state: RootState) => state.standings.status

// Thunks are commonly used for async logic like fetching data.
// The `createAsyncThunk` method is used to generate thunks that
// dispatch pending/fulfilled/rejected actions based on a promise.
// In this example, we make a mock async request and return the result.
// The `createSlice.extraReducers` field can handle these actions
// and update the state with the results.
export const fetchAsync = createAsyncThunk(
  "standings/fetchStandings",
  async (isLoggedIn:boolean) => {


    if (!isLoggedIn) {
      return <SerializablePredictedStandings>{}
    }

    const response = await fetchStandings()
    // The value we return becomes the `fulfilled` action payload
    return response
  },
)
