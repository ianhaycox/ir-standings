// This file demonstrates typical usage of Redux Toolkit's createSlice function
// for defining reducer logic and actions, as well as related thunks and selectors.

import { createAsyncThunk, createSlice } from "@reduxjs/toolkit"
import type { RootState } from "../../app/store"
import { fetchStandings } from "./standingsAPI"


export interface SerializablePredictedStanding {
  cust_id: number;
  driver_name: string;
  car_number?: string;
  current_position?: number;
  predicted_position: number;
  current_points: number;
  predicted_points: number;
  change: number;
  car_names: string[];
}

export interface SerializableStanding {
  sof_by_car_class: number;
  car_class_id: number;
  car_class_name: string;
  class_leader_laps_complete: number;
  items: SerializablePredictedStanding[];
}

export interface SerializablePredictedStandings {
  status: string;
  track_name: string;
  count_best_of: number;
  standings: {[key: number]: SerializableStanding}; // By Car Class ID
}

export interface PS {
  cust_id: number;
  driver_name: string;
  car_number?: string;
  current_position?: number;
  predicted_position: number;
  current_points: number;
  predicted_points: number;
  change: number;
}

// Define the TS type for the standings slice's state
export interface StandingsState {
  standings: SerializablePredictedStandings
  status: "idle" | "loading" | "failed"
}

// Define the initial value for the slice state
const initialState: StandingsState = {
  standings: <SerializablePredictedStandings>{},
  status: "idle",
}

// Slices contain Redux reducer logic for updating state, and
// generate actions that can be dispatched to trigger those updates.
export const standingsSlice = createSlice({
  name: "standings",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(getPastResults.pending, state => {
        state.status = "loading"
      })
      .addCase(getPastResults.fulfilled, (state, action) => {
        state.status = "idle"
        state.standings = action.payload //  serialize(action.payload)
      })
      .addCase(getPastResults.rejected, state => {
        state.status = "failed"
      })
  },
})

// Export the slice reducer for use in the store configuration
export default standingsSlice.reducer

export const selectStandings = (state: RootState) => state.standings.standings
export const selectStatus = (state: RootState) => state.standings.status

export const getPastResults = createAsyncThunk(
  "standings/fetchStandings",
  async (isLoggedIn:boolean) => {


    if (!isLoggedIn) {
      return <SerializablePredictedStandings>{}
    }

    const response = await fetchStandings()
    // The value we return becomes the `fulfilled` action payload
    return response
  },
)
