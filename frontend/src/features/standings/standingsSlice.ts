// This file demonstrates typical usage of Redux Toolkit's createSlice function
// for defining reducer logic and actions, as well as related thunks and selectors.

import { createAsyncThunk, createSlice } from "@reduxjs/toolkit"
import type { PayloadAction } from "@reduxjs/toolkit"
import { main } from '../../../wailsjs/go/models';

import type { RootState, AppThunk } from "../../app/store"

import { fetchStandings } from "./standingsAPI"

export interface PS {
  cust_id: number;
  driver_name: string;
  car_number?: string;
  current_position?: number;
  predicted_position: number;
  current_points: number;
  predicted_points: number;
  change: number;
}

// Define the TS type for the standings slice's state
export interface StandingsState {
  items: PS[] //  main.PredictedStandings
  status: "idle" | "loading" | "failed"
}

// Define the initial value for the slice state
const initialState: StandingsState = {
  items: Array<PS>(),
  status: "idle",
}

// Slices contain Redux reducer logic for updating state, and
// generate actions that can be dispatched to trigger those updates.
export const standingsSlice = createSlice({
  name: "standings",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    set: state => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      let xx = new main.PredictedStandings({ "items": [
        { "cust_id": 1, "predicted_position":1, "car_number":"23", "driver_name": "Bob", "predicted_points":108, "current_position":1, "change":0},
        { "cust_id": 2, "predicted_position":2, "car_number":"33", "driver_name": "John", "predicted_points":100, "current_position":3, "change":1},
        { "cust_id": 3, "predicted_position":3, "car_number":"03", "driver_name": "Slow James", "predicted_points":90, "current_position":2, "change":-1},
      ] });

      let yy = Array<PS>()
      xx.items.map(row => yy.push({
        cust_id: row.cust_id,
        predicted_position: row.predicted_position,
        car_number: row.car_number,
        driver_name: row.driver_name,
        predicted_points: row.predicted_points,
        current_position: row.current_position,
        change: row.change,
        current_points: row.current_points,
      }))
      state.items = yy
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(fetchAsync.pending, state => {
        state.status = "loading"
      })
      .addCase(fetchAsync.fulfilled, (state, action) => {
        state.status = "idle"
        state.items = action.payload.convertValues(action.payload, Array<PS>, false) // TODO - see above
      })
      .addCase(fetchAsync.rejected, state => {
        state.status = "failed"
      })
  },
})

// Export the generated action creators for use in components
export const { set } = standingsSlice.actions

// Export the slice reducer for use in the store configuration
export default standingsSlice.reducer

// Selector functions allows us to select a value from the Redux root state.
// Selectors can also be defined inline in the `useSelector` call
// in a component, or inside the `createSlice.selectors` field.
export const selectStandings = (state: RootState) => state.standings.items
export const selectStatus = (state: RootState) => state.standings.status

// Thunks are commonly used for async logic like fetching data.
// The `createAsyncThunk` method is used to generate thunks that
// dispatch pending/fulfilled/rejected actions based on a promise.
// In this example, we make a mock async request and return the result.
// The `createSlice.extraReducers` field can handle these actions
// and update the state with the results.
export const fetchAsync = createAsyncThunk(
  "standings/fetchStandings",
  async (amount: number) => {
    const response = await fetchStandings()
    // The value we return becomes the `fulfilled` action payload
    return response
  },
)
